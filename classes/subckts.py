#!/usr/bin/env python
import os

class subckts:

    def __init__(self, uut, fet_size, fet_nfin, fet_voltage):
        self.uut = uut # name of unit under test, e.g. inverter
        self.fet_size = fet_size # fet length size, e.g. 14nm, 10nm, 7nm
        self.fet_nfin = fet_nfin # fin size?? e.g. 1000m
        self.fet_voltage = fet_voltage # nominal voltage for ptm model


    '''Inputs and Outputs LOADS'''

    def write_source(self, uut_size):
        '''Write input source of system to .sp file'''
            # inputs uut_size, load ammount, sim_time
        for instance in range(uut_size):
            fall_time = (2) * (2 ** instance)
            rise_time = str(fall_time / 2)
            fall_time = str(fall_time)
            instance = str(instance)
            self.uut.write("vin_" + instance + " inb_" + instance + " gnd  PULSE(" + self.fet_voltage + "V " + "0V 0ns 50ps 50ps " + rise_time + "n " + fall_time + "n)\n")
            # call instance of input source subckt in uut file
            self.uut.write("xinput_" + instance + " inb_" + instance + " outin_0" + instance + " vdd " + "inverter\n")
        self.uut.write("\n")
        return None

    def write_outputs(self, uut_size, tag, outin):
        '''Write output load of system to .sp file'''
        for instance in range(uut_size):
            inout = str(outin + 1)
            for output_tag in range(tag):
                instance = str(instance) # instance of ouput to evaluate
                output_tag = str(output_tag) # amount of load per output
                # call instance of ouput load subckt in uut file
                self.uut.write("xoutput_" + instance + output_tag + " outin_" + inout  + instance + " outb_" + instance + output_tag + " vdd " + "inverter\n")
        self.uut.write("\n")
        return None


    '''UUTs'''
    def set_inverter_subckt(self):
        '''Write inverter subckt'''
        # declare subckt name, input, output, and source
        self.uut.write(".subckt inverter in out vdd\n")
        self.uut.write("$FETs" + "\n")
        # call pfet model name, and decaler its input, output, and source
        self.uut.write("xpfet out in vdd vdd pfet l=" + self.fet_size + "n nfin=" + self.fet_nfin + "\n")
        # call nfet model name, and decaler its input, output, and source
        self.uut.write("xnfet out in gnd gnd nfet l=" + self.fet_size + "n nfin=" + self.fet_nfin + "\n")
        self.uut.write(".ends\n") # end subckt declaration
        self.uut.write("\n")
        return None

    def write_inverter(self, uut_size, serial_instance):
        '''Write inverter device'''
        for instance in range(uut_size):
            for outin in range(serial_instance):
                instance = str(instance)
                inout = str(outin + 1)
                outin = str(outin)
                # declare subckt name, input, output, and source
                self.uut.write("xinverter" + outin + instance + " " + "outin_" + outin  + instance + " " + "outin_" + inout + instance + " vdd " + "inverter\n")
        self.uut.write("\n")
        return None


    '''Analysis and Measurements'''

    def set_library(self, script_path, subuut, uut):
        self.uut.write("$This UUT was automatically generated by:\n")
        self.uut.write("$" + script_path + "\n")
        self.uut.write("$Netlist of " + uut + "\n")
        self.uut.write(".lib '../models' " + subuut + "\n\n")
        return None

    def analysis_type(self, sim_type, sim_tinc, sim_time):
        self.uut.write("$Simulation/Analysis Type\n")
        self.uut.write(".option post=2\n")
        self.uut.write("." + sim_type + " " + sim_tinc + " " + sim_time + "ns\n\n")
        self.uut.write(".end")
        return None

    def run_hspice(self, script_dir, subuut, uut):
        os.chdir(uut)
        os.system('hspice ' + subuut + ".sp > " + subuut + ".lis")
        os.chdir(script_dir)
        return None

    def read_meas(self, start_str, end_str, line, lis_flag, lis_series):
        if (start_str in line):
            lis_flag = 1
        elif (end_str in line) and (lis_flag == 1):
            lis_flag = 0
        elif (lis_flag == 1):
            lis_series.append(line.split())
        return (lis_flag, lis_series)

    def collect_data(self, cwd, subuut, uut):
        power_series = []
        delay_series = []
        timing_series = []
        with open(cwd + "/" + uut + "/" + subuut + ".lis") as results:
            timing_flag = 0
            delay_flag = 0
            power_flag = 0
            for line in results:
                (power_flag, power_series) = self.read_meas("transient analysis", "trf", line, power_flag, power_series)
                (delay_flag, delay_series) = self.read_meas("source_power", "x\n", line, delay_flag, delay_series)
                (timing_flag, timing_series) = self.read_meas("x\n", "y\n", line, timing_flag, timing_series)
        return (power_series, delay_series, timing_series)

    def measure_delays(self, uut_size, serial_instance):
        vdd_50 = str(float(self.fet_voltage) / 2)
        for instance in range(uut_size):
            rise_fall_count = 2 ** ((uut_size - instance) - 1)
            for outin in range(serial_instance):
                inout = str(outin + 1)
                outin = str(outin)
                for rise_fall in range(rise_fall_count ):
                    rise_fall = str(rise_fall + 1)
                    instance = str(instance)
                    # use instance to derive a method that will calculate all delays and an average
                    self.uut.write(".measure tran trf_delay_" + outin + instance + rise_fall + " trig v(" + "outin_" + outin + instance + ") val=" + vdd_50 + " rise=" + rise_fall + " targ v(" + "outin_" + inout + instance + ") val=" + vdd_50 + " fall=" + rise_fall + "\n")
                    # automate to print per uut subckt
                    self.uut.write(".measure tran tfr_delay_" + outin + instance + rise_fall + " trig v(" + "outin_" + outin + instance + ") val=" + vdd_50 + " fall=" + rise_fall + " targ v(" + "outin_" + inout + instance + ") val=" + vdd_50 + " rise=" + rise_fall + "\n")
        return None

    def measure_power(self, uut_size, sim_time, serial_instance):
        for instance in range(uut_size):
            for outin in range(serial_instance):
                instance = str(instance)
                outin = str(outin)
                # automate to print per uut subckt, create subckt uut to calculate power of entire uut
                self.uut.write(".measure tran inv_avg_power" + outin + instance  + " avg p(x" + "inverter" + outin + instance + ") from=0ns to=" + sim_time + "ns\n")
                # automate to print per uut subckt
                self.uut.write(".measure tran peakpower" + outin + instance  + " max p(x" + "inverter" + outin + instance + ")\n")

        self.uut.write(".measure tran source_power avg power\n")
        return None

    def print_wave(self, uut_size, serial_instance):
        for instance in range(uut_size):
            for outin in range(serial_instance):
                instance = str(instance)
                inout = str(outin + 1)
                outin = str(outin)
                # automate to print per uut subckt, need to use instance and tags
                self.uut.write(".print TRAN V(" + "outin_" + outin + instance + ") V(" + "outin_" + inout + instance + ")\n")
        return None

#   def write_dram(self, instance):

